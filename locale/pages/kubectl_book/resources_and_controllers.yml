texts:
  en: >-
    {% panel style="success", title="Providing Feedback" %}

    **Provide feedback at the [survey](https://www.surveymonkey.com/r/JH35X82)**

    {% endpanel %}
  ja: ""
---
texts:
  en: '{% panel style="info", title="TL;DR" %}'
  ja: __COPY__
---
texts:
  en: A Kubernetes API has 2 parts - a Resource Type and a Controller
  ja: Kubernetes API は 2 つの部分からなります - リソースタイプとコントローラ
---
texts:
  en: Resources are objects declared as json or yaml and written to a cluster
  ja: リソースは json や yaml で宣言されたオブジェクトで、クラスタに書き込まれます
---
texts:
  en: >-
    Controllers asynchronously actuate Resources after they are stored

    {% endpanel %}
  ja: >-
    コントローラはリソースの保存後に非同期にリソースを動かします

    {% endpanel %}
---
texts:
  en: Kubernetes Resources and Controllers Overview
  ja: Kubernetes のリソースとコントローラの概要
---
texts:
  en: >-
    This section provides background on the Kubernetes Resource model.  This information

    is also available at the [kubernetes.io](https://kubernetes.io/docs/home/) docs site.
  ja: この章では Kubernetes リソースモデルの背景を説明します。ここに書かれていることは [kubernetes.io](https://kubernetes.io/docs/home/) のドキュメントでも確認できます。
---
texts:
  en: "For more information on Kubernetes Resources see: [kubernetes.io Concepts](https://kubernetes.io/docs/concepts/)."
  ja: Kubernetes リソースの詳細は [kubernetes.io コンセプト](https://kubernetes.io/docs/concepts/)をご覧ください。
---
texts:
  en: Resources
  ja: リソース
---
texts:
  en: >-
    Instances of Kubernetes objects (e.g. Deployment, Services, Namespaces, etc)

    are called **Resources**.
  ja: Kubernetes オブジェクト (Deployment、Service、名前空間など) のインスタンスは**リソース**と呼ばれます。
---
texts:
  en: Resources which run containers are referred to as **Workloads**.
  ja: コンテナを実行するリソースは特にワークロードといいます。
---
texts:
  en: "Examples of Workloads:"
  ja: ワークロードの例。
---
texts:
  en: "[Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)"
  ja: __COPY__
---
texts:
  en: "[StatefulSets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)"
  ja: __COPY__
---
texts:
  en: "[Jobs](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)"
  ja: __COPY__
---
texts:
  en: "[CronJobs](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)"
  ja: __COPY__
---
texts:
  en: "[DaemonSets](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/) "
  ja: __COPY__
---
texts:
  en: >-
    **Users work with Resource APIs by declaring them in files which are then Applied to a Kubernetes

    cluster.  These declarative files are called Resource Config.**
  ja: "**リソース API を使うには、まずリソースをファイルで宣言し、それから Kubernetes クラスタに適用します。これらの宣言的なファイルはリソース設定と呼ばれます。**"
---
texts:
  en: >-
    Resource Config is *Applied* (declarative Create/Update/Delete) to a Kubernetes cluster using

    tools such as Kubectl, and then actuated by a *Controller*.
  ja: リソース設定は、Kubectl のようなツールを使って Kubernetes クラスタに (宣言的な作成・更新・削除を) 適用され、それから**コントローラ**が作動させます。
---
texts:
  en: "Resources are uniquely identified:"
  ja: リソースは一意に識別されます。
---
texts:
  en: "**apiVersion** (API Type Group and Version)"
  ja: "**apiVersion** (API タイプのグループとバージョン)"
---
texts:
  en: "**kind** (API Type Name)"
  ja: "**kind** (API タイプの名前)"
---
texts:
  en: "**metadata.namespace** (Instance namespace)"
  ja: "**metadata.namespace** (インスタンスの名前空間)"
---
texts:
  en: "**metadata.name** (Instance name)"
  ja: "**metadata.name** (インスタンス名)"
---
texts:
  en: >-
    {% panel style="warning", title="Default Namespace" %}

    If namespace is omitted from the Resource Config, the *default* namespace is used.  Users

    should almost always explicitly specify the namespace for their Application using a

    `kustomization.yaml`.

    {% endpanel %}
  ja: >-
    {% panel style="warning", title="デフォルトの名前空間" %}

    リソース設定で名前空間が省略されると *default* という名前空間が使用されます。ほとんどの場合、アプリケーションには明示的に名前空間を指定すべきです。名前空間は `kustomization.yaml` に記述します。
    {% endpanel %}
---
texts:
  en: "{% method %}"
  ja: __COPY__
---
texts:
  en: Resources Structure
  ja: リソースの構造
---
texts:
  en: Resources have the following components.
  ja: リソースの構成要素は次の通りです。
---
texts:
  en: "**TypeMeta:** Resource Type **apiVersion** and **kind**."
  ja: "**TypeMeta:** リソースタイプの **apiVersion** と**種類**"
---
texts:
  en: "**ObjectMeta:** Resource **name** and **namespace** + other metadata (labels, annotations, etc)."
  ja: "**ObjectMeta:** リソースの**名前**と**名前空間** + 他のメタデータ (ラベル、アノテーションなど)"
---
texts:
  en: "**Spec:** the desired state of the Resource - intended state the user provides to the cluster."
  ja: "**Spec:** リソースの望ましい状態 - クラスタに対して教えるこうなってほしいという状態"
---
texts:
  en: "**Status:** the observed state of the object - recorded state the cluster provides to the user."
  ja: "**Status:** オブジェクトの観測された状態 - クラスタが教えてくれる記録された状態"
---
texts:
  en: Resource Config written by the user omits the Status field.
  ja: リソース設定を書くときには Status フィールドは省略します。
---
texts:
  en: >-
    **Example Deployment Resource Config**

    {% sample lang="yaml" %}
  ja: >-
      **Deployment のリソース設定の例**

    {% sample lang="yaml" %}
---
texts:
  en: "{% endmethod %}"
  ja: __COPY__
---
texts:
  en: >-
    {% panel style="info", title="Spec and Status" %}

    Resources such as ConfigMaps and Secrets do not have a Status,

    and as a result their Spec is implicit (i.e. they don't have a spec field).

    {% endpanel %}
  ja: >-
    {% panel style="info", title="Spec and Status" %}

    ConfigMap や Secret のようなリソースには Status がありません。その結果、それらの Spec は暗黙的です (言い換えると spec フィールドがありません)。

    {% endpanel %}
---
texts:
  en: Controllers
  ja: コントローラ
---
texts:
  en: >-
    Controllers actuate Kubernetes APIs.  They observe the state of the system and look for

    changes either to desired state of Resources (create, update, delete) or the system

    (Pod or Node dies).
  ja: コントローラは Kubernetes API を作動します。コントローラはシステムの状態を監視し、リソースを望ましい状態にするための変更 (作成、更新、削除) や、システムの変更 (Pod や Node の停止) を検知します。
---
texts:
  en: >-
    Controllers then make changes to the cluster to fulfill the intent specified by the user

    (e.g. in Resource Config) or automation (e.g. changes from Autoscalers).
  ja: >-
    コントローラはユーザーが (たとえばリソース設定の中で) 決めた意図通りの仕様や (たとえば Autoscaler による) 自動化の要求を満たすようクラスタを変更ます。
---
texts:
  en: >-
    **Example:** After a user creates a Deployment, the Deployment Controller will see

    that the Deployment exists and verify that the corresponding ReplicaSet it expects

    to find exists.  The Controller will see that the ReplicaSet does not exist and will

    create one.
  ja: "**例**: Deployment が作成されると、Deployment コントローラは Deployment が存在することを理解し、対応する ReplicaSet が期待どおりに存在するかどうか検証します。ReplicaSet が存在しなければ作成します。"
---
texts:
  en: >-
    {% panel style="warning", title="Asynchronous Actuation" %}

    Because Controllers run asynchronously, issues such as a bad

    Container Image or unschedulable Pods will not be present in the CRUD response.

    Tooling must facilitate processes for watching the state of the system until changes are

    completely actuated by Controllers.  Once the changes have been fully actuated such

    that the desired state matches the observed state, the Resource is considered *Settled*.

    {% endpanel %}
  ja: >-
    {% panel style="warning", title="非同期な動作" %}

    コントローラは非同期に実行されるため、コンテナイメージが壊れているとか Pod がスケジュール不能であるとかといった問題は CRUD のレスポンスでは顕在化しません。何かツールを作る場合には、コントローラの動作が完了するまでシステムの状態を監視しておくことが簡単にできるようにすべきです。変更動作が完了して望ましい状態が現在の状態と一致したら、リソースは**安定状態にある**なとみなされます。

    {% endpanel %}
---
texts:
  en: Controller Structure
  ja: コントローラの構造
---
texts:
  en: "**Reconcile**"
  ja: "**調停**"
---
texts:
  en: >-
    Controllers actuate Resources by reading the Resource they are Reconciling + related Resources,

    such as those that they create and delete.
  ja: コントローラは自身が作成・削除するなどして調停中のリソースとその関連リソースを読み込むことによって、リソースを作動させます。
---
texts:
  en: >-
    **Controllers *do not* Reconcile events, rather they Reconcile the expected

    cluster state to the observed cluster state at the time Reconcile is run.**
  ja: "**コントローラが実行する調停は、イベントを調停するの*ではなく*、期待されるクラスタの状態を現在のクラスタの状態に調停します。**"
---
texts:
  en: Deployment Controller creates/deletes ReplicaSets
  ja: Deployment コントローラは ReplicaSets を作成・削除します
---
texts:
  en: ReplicaSet Controller creates/delete Pods
  ja: ReplicaSet コントローラは Pod を作成・削除します
---
texts:
  en: Scheduler (Controller) writes Nodes to Pods
  ja: Scheduler (コントローラ) は Node を Pod に書き込みます
---
texts:
  en: Node (Controller) runs Containers specifid in Pods on the Node
  ja: Node (コントローラ) は Node 上の Pod に定義されたコンテナを実行します
---
texts:
  en: "**Watch**"
  ja: "**監視**"
---
texts:
  en: >-
    Controllers actuate Resources *after* they are written by Watching Resource Types, and then

    triggering Reconciles from Events.  After a Resource is created/updated/deleted, Controllers

    Watching the Resource Type will receive a notification that the Resource has been changed,

    and they will read the state of the system to see what has changed (instead of relying on

    the Event for this information).
  ja: コントローラがリソースを作動させるのは監視用のリソースタイプが書き、それからイベントから調停がトリガーされた**後**です。リソースが作成・更新・削除された後、リソースタイプを監視しているコントローラはリソースが変更されたという通知を受け取り、(この情報のためのイベントに依存することなく) システムの状態を読み込んで何を変更すべきかを理解します。
---
texts:
  en: Deployment Controller watches Deployments + ReplicaSets (+ Pods)
  ja: Deployment コントローラは Deployment と ReplicaSet (と Pod) を監視します。
---
texts:
  en: ReplicaSet Controller watches ReplicaSets + Pods
  ja: ReplicaSet コントローラは ReplicaSets と Pod を監視します
---
texts:
  en: Scheduler (Controller) watches Pods
  ja: Scheduler (コントローラ) は Pod を監視します
---
texts:
  en: Node (Controller) watches Pods (+ Secrets + ConfigMaps)
  ja: Node (コントローラ) は Pod (と Secret と ConfigMap) を監視します
---
texts:
  en: >-
    {% panel style="info", title="Level vs Edge Based Reconciliation" %}

    Because Controllers don't respond to individual Events, but instead Reconcile the state

    of the system at the time that Reconcile is run, **changes from several different events may be observed

    and Reconciled together.**  This is referred to as a *Level Based* system, whereas a system that

    responds to each event individually would be referred to as an *Edge Based* system.

    {% endpanel %}
  ja: >-
    {% panel style="info", title="レベルベースの調停とエッジベースの調停" %}

    Because Controllers don't respond to individual Events, but instead Reconcile the state
    コントローラは個々のイベントに反応せず、調停が実行されるときにシステムの状態を調停するため、**複数の異なるイベントから来る複数の変更が観測されうるし、一緒に調停されるかもしれません。**これは**レベルベース**のシステムと呼ばれます。それと対比して、個々のイベントに対して反応するシステムは**エッジベース**のシステムと呼ばれます。

    {% endpanel %}
---
texts:
  en: Overview of Kubernetes Resource APIs
  ja: Kubernetes リソース API の概要
---
texts:
  en: Pods
  ja: Pod
---
texts:
  en: >-
    Containers are run in [*Pods*](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) which are

    scheduled to run on *Nodes* (i.e. worker machines) in a cluster.
  ja: __COPY__
---
texts:
  en: "Pods run a *single replica* of an Application and provide:"
  ja: __COPY__
---
texts:
  en: Compute Resources (cpu, memory, disk)
  ja: __COPY__
---
texts:
  en: Environment Variables
  ja: __COPY__
---
texts:
  en: Readiness and Health Checking
  ja: __COPY__
---
texts:
  en: Network (IP address shared by containers in the Pod)
  ja: __COPY__
---
texts:
  en: Mounting Shared Configuration and Secrets
  ja: __COPY__
---
texts:
  en: Mounting Storage Volumes
  ja: __COPY__
---
texts:
  en: Initialization
  ja: __COPY__
---
texts:
  en: >-
    {% panel style="warning", title="Multi Container Pods" %}

    Multiple replicas of an Application should be created using a Workload API to manage

    creation and deletion of Pod replicas using a PodTemplate.
  ja: __COPY__
---
texts:
  en: >-
    In some cases a Pod may contain multiple Containers forming a single instance of an Application.  These

    containers may coordinate with one another through shared network (IP) and storage.

    {% endpanel %}
  ja: __COPY__
---
texts:
  en: Workloads
  ja: __COPY__
---
texts:
  en: >-
    Pods are typically managed by higher level abstractions that handle concerns such as

    replication, identity, persistent storage, custom scheduling, rolling updates, etc.
  ja: __COPY__
---
texts:
  en: "The most common out-of-the-box Workload APIs (manage Pods) are:"
  ja: __COPY__
---
texts:
  en: "[Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) (Stateless Applications)"
  ja: __COPY__
---
texts:
  en: replication + rollouts
  ja: __COPY__
---
texts:
  en: "[StatefulSets](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/) (Stateful Applications)"
  ja: __COPY__
---
texts:
  en: replication + rollouts + persistent storage + identity
  ja: __COPY__
---
texts:
  en: "[Jobs](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/) (Batch Work)"
  ja: __COPY__
---
texts:
  en: run to completion
  ja: __COPY__
---
texts:
  en: "[CronJobs](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/) (Scheduled Batch Work)"
  ja: __COPY__
---
texts:
  en: scheduled run to completion
  ja: __COPY__
---
texts:
  en: "[DaemonSets](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/) (Per-Machine)"
  ja: __COPY__
---
texts:
  en: per-Node scheduling
  ja: __COPY__
---
texts:
  en: >-
    {% panel style="success", title="API Abstraction Layers" %}

    High-level Workload APIs may manage lower-level Workload APIs instead of directly managing Pods

    (e.g. Deployments manage ReplicaSets).

    {% endpanel %}
  ja: __COPY__
---
texts:
  en: Service Discovery and Load Balancing
  ja: __COPY__
---
texts:
  en: >-
    Service discovery and Load Balancing may be managed by a *Service* object.  Services provide a single

    virtual IP address and dns name load balanced to a collection of Pods matching Labels.
  ja: __COPY__
---
texts:
  en: '{% panel style="info", title="Internal vs External Services" %}'
  ja: __COPY__
---
texts:
  en: >-
    [Services Resources](https://kubernetes.io/docs/concepts/services-networking/service/)

    (L4) may expose Pods internally within a cluster or externally through an HA proxy.
  ja: __COPY__
---
texts:
  en: >-
    [Ingress Resources](https://kubernetes.io/docs/concepts/services-networking/ingress/) (L7)
      may expose URI endpoints and route them to Services.
    {% endpanel %}
  ja: __COPY__
---
texts:
  en: Configuration and Secrets
  ja: __COPY__
---
texts:
  en: >-
    Shared Configuration and Secret data may be provided by ConfigMaps and Secrets.  This allows

    Environment Variables, Command Line Arguments and Files to be loosely injected into

    the Pods and Containers that consume them.
  ja: __COPY__
---
texts:
  en: '{% panel style="info", title="ConfigMaps vs Secrets" %}'
  ja: __COPY__
---
texts:
  en: >-
    [ConfigMaps](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)

    are for providing non-sensitive data to Pods.
  ja: __COPY__
---
texts:
  en: >-
    [Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)
      are for providing sensitive data to Pods.
    {% endpanel %}
  ja: __COPY__
